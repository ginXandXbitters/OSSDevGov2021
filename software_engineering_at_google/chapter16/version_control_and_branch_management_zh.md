##### 分支尽量不要长时间存在

一版规则中隐含了一些更深层次的思想和政策； 其中最重要的一点是：开发部门应该最少，或者最好是短暂的。这源于过去20年中许多已发表的工作，从敏捷过程到DORA关于基于主干的开发甚至Phoenix项目的研究结果 关于减少工作量的<sup> 12 </sup>课程。 当我们加入类似于dev分支的挂起工作的想法时，这进一步强调了应针对定期提交的主干以较小的增量进行工作。

作为反例：在一个严重依赖长期存在的开发分支的开发社区中，不难想象选择机会会重新出现。

想象一下这种情况：一些基础架构团队正在开发一个新的Widget，比旧的Widget更好。兴奋增加。其他新近启动的项目问：“我们可以依靠您的新Widget吗？”显然，如果您已经对代码库可见性策略进行了投资，则可以解决此问题，但是当“允许”新的Widget但它仅存在于并行分支中时，就会发生深层的问题。请记住：添加依赖项时，新开发一定不能选择。应当将新的Widget提交到主干，从运行时禁用直到准备就绪，并在可能的情况下通过可见性向其他开发人员隐藏-或设计两个Widget选项以使它们可以共存，并链接到相同的程序中。
有趣的是，已经有证据表明这在行业中很重要。 DORA在Accelerate和DevOps的最新状态报告中指出，基于主干的开发与高性能软件组织之间存在可预测的关系。 Google并不是唯一一个发现这一点的组织-当这些政策演变时我们也未必一定会想到预期的结果-似乎其他措施都没有。 DORA的结果肯定符合我们的经验。

我们用于大规模变更的策略和工具（LSC；请参阅第22章）更加注重基于主干的开发的重要性：在修改所有内容时，跨代码库应用的广泛/浅层变更已经是一项艰巨的任务（通常是乏味的） 签入主干分支。 拥有大量可能需要同时重构的其他开发分支将是执行这些类型的更改的巨大负担，需要找到数量不断扩大的隐藏分支。 在DVCS模型中，甚至可能无法识别所有这些分支。

> 12 Kevin Behr，Gene Kim和George Spafford，《凤凰计划》（波特兰：IT Revolution Press，2018年）。

当然，我们的经验不是普遍的。您可能会发现自己处在不寻常的情况下，这些情况需要寿命更长的dev分支与主干并行（并与主干定期合并）。
这些情况应该很少见，应该理解为昂贵。在使用Google monorepo的大约1000个团队中，只有几个团队拥有这样的dev分支。<sup> 13 </sup>通常，存在这些团队的原因非常特殊（非常不寻常）。这些原因大多数归结为“随着时间的流逝，我们对兼容性的要求非常不同”。通常，这是确保不同版本之间静态数据的兼容性的问题：某些文件格式的读取器和写入器需要在一段时间内就该格式达成一致，即使读取器或写入器的实现已被修改。有时，长期存在的dev分支可能来自有希望的API兼容性（当一个版本不够用时，我们需要保证较旧版本的微服务客户端仍可与较新的服务器一起使用，反之亦然）。这可能是一个非常具有挑战性的要求，对于积极发展的API，您不应该轻率地承诺，并且应谨慎对待，以确保一段时间不会意外增长。与时间不变的代码相比，任何形式的时间依赖性都更加昂贵和复杂。在内部，Google生产服务对这种形式的承诺相对较少。<sup> 14 </sup>我们还从“内部版本”施加的潜在版本偏斜的上限中受益匪浅
范围”：每六个月最多要重建和重新部署生产中的每个工作。 （通常比这要频繁得多。）
我们确定还有其他情况可能需要长期存在的dev分支。只需确保使其稀有即可。如果您采用本书中讨论的其他工具和实践，许多工具和方法将趋向于长期存在的dev分支施加压力。自动化和工具在主干上非常有效，但对于dev分支却失败（或需要更多的努力），可以帮助鼓励开发人员保持最新状态。

> 13很难获得准确的数量，但这类团队的数量几乎肯定少于10个。
> 14云接口是另一回事。

##### 那发行分支呢？

许多Google团队使用发行分支，但只能挑选少量樱桃。 如果您要发布每月发行版本并继续努力开发下一个发行版本，那么建立一个发行分支是完全合理的。 同样，如果您要将设备运送给客户，则准确了解“现场”发布的版本非常重要。 请谨慎行事，尽量避免采摘樱桃，也不打算与树干重新融合。 鉴于相对较少的团队已经达到CD承诺的那种快速发布节奏（请参阅第24章），从而消除了对发布分支的需求，因此我们的各个团队对发布分支有各种各样的政策。 一般来说，发行分支机构不会给我们的经验造成任何广泛的损失。 或者，至少没有任何明显的成本超过VCS的额外固有成本。

### Monorepos

在2016年，我们发表了一篇有关Google的monorepo方法的文章（受到广泛引用）。<sup> 15 </sup> monorepo方法具有一些固有的优势，其中主要的一点是，遵守One Version是微不足道的：通常违反一个版本比做正确的事情要困难得多。无需确定任何版本的正式版本或发现重要存储库的过程。用来了解构建状态的构建工具（请参见第23章）也不需要发现重要存储库的位置。一致性有助于扩大引入新工具和优化的影响。总的来说，工程师可以看到其他人在做什么，并将其用于告知自己在代码和系统设计中的选择。这些都是非常好的东西。
考虑到所有这些以及我们对“单版本规则”优点的信念，合理地问一句Monorepo是否是“唯一真实的方式”是合理的。相比之下，开源社区似乎可以使用“ manyrepo”方法很好地工作，该方法基于看似无限数量的非协调和非同步项目存储库。
简而言之：不，我们不认为像我们描述的那样，monorepo方法对每个人都是完美的答案。继续在文件系统格式和VCS之间进行并行处理，可以想像一下，决定使用10个驱动器来提供一个非常大的逻辑文件系统，还是提供10个较小的单独访问的文件系统。在文件系统世界中，两者都有优点和缺点。评估文件系统选择时的技术问题包括中断弹性，大小限制，性能特征等。可用性问题可能会更多地集中在跨文件系统边界引用文件，添加符号链接和同步文件的能力。
一组非常相似的问题决定了是要使用monorepo还是更细粒度的存储库。关于如何存储源代码（或存储文件）的具体决策很容易引起争议，并且在某些情况下，组织和工作流程的特定问题比其他问题更重要。这些都是您需要自己做出的决定。
重要的不在于我们是否专注于monorepo。它应尽可能地遵守“单版本”原则：将依赖项添加到组织中已在使用的某些库时，开发人员不能选择。违反“一版规则”的选择会导致合并策略讨论，钻石依赖，工作丢失和精力浪费。

> 15 Rachel Potvin和Josh Levenberg，“为什么Google在一个存储库中存储数十亿行代码”，Com-
> ACM通报，59 No.7（2016）：78-87。

包括VCS和构建系统在内的软件工程工具越来越多地提供在细粒度存储库和mon-repos之间进行巧妙融合的机制，以提供类似于monorepo的体验-约定的提交顺序和对依赖关系图的理解。 Git子模块，具有外部依赖项的Bazel以及CMake子项目都允许现代开发人员合成一些近似于monorepo行为的东西，而没有monorepo的成本和缺点。<sup> 16 </sup>例如，细粒度的存储库更容易和规模（Git在提交几百万次提交后经常会出现性能问题，并且在存储库中包含大型二进制工件时，克隆速度往往很慢）和存储（VCS元数据可能会加起来，尤其是当您的版本中存在二进制工件时）张力控制系统）。联邦/虚拟monorepo（VMR）样式的存储库中的细粒度存储库可以更轻松地隔离实验或绝密项目，同时仍保持“一个版本”并允许访问通用实用程序。
换句话说，如果组织中的每个项目都具有相同的保密性，法律性，隐私性和安全性要求，那么<sup> 17 </sup>真正的monorepo是一个不错的选择。否则，请瞄准monorepo的功能，但要让自己灵活地以其他方式实施该体验。如果您可以使用不连贯的存储库进行管理并坚持使用一个版本，或者您的工作负载都已断开以足以创建真正独立的存储库，那就太好了。否则，以某种方式合成类似VMR的东西可能代表两全其美。
毕竟，您选择的文件系统格式实际上与您写入文件的格式无关紧要。

### 版本控制的未来

Google不是唯一公开讨论Monorepo方法的好处的组织。 微软，Facebook，Netflix和Uber也公开提到了对这种方法的依赖。 DORA已对此进行了广泛的出版。 大概所有这些成功且历史悠久的公司都受到了误导，或者至少它们的情况存在很大差异，以致于不适用于规模较小的普通组织。 尽管有可能，但我们认为这是不可能的。
大多数反对monorepos的争论都集中在拥有单个大型存储库的技术限制上。 如果从上游克隆存储库又快又便宜，那么开发人员更有可能将更改保持较小且孤立的状态（并避免进行

> 16我们认为没有什么事情能如此顺利地完成，但是存储库间的依赖关系/虚拟monorepo的想法显然已经浮现。
> 17或者，您有意愿和能力自定义您的VCS，并在代码库/组织的整个生命周期中保持这种自定义。 再说一次，也许不打算以此作为选择； 那是很多开销。

提交到错误的在制品分支的错误）。如果克隆存储库（或执行其他一些常见的VCS操作）需要花费数小时的开发人员时间，那么您可以轻松地了解为什么组织会回避依赖这种存储库的原因。
大型存储库/操作。幸运的是，我们专注于提供可大规模扩展的VCS，从而避免了这种陷阱。

回顾过去几年对Git的重大改进，显然已经做了很多工作来支持更大的存储库：浅克隆，稀疏分支，更好的优化等。我们希望这种情况将继续下去，并且“但我们需要使存储库保持较小”的重要性将逐渐减少。

反对monorepos的另一个主要论点是，它与开放源码软件（OSS）世界中的发展方式不匹配。尽管是正确的，但OSS世界中的许多实践（正确地）来自优先考虑自由，缺乏协调和缺乏计算资源。在OSS世界中，独立的项目实际上是独立的组织，它们碰巧能够看到彼此的代码。在组织的边界内，我们可以做更多的假设：我们可以假设计算资源的可用性，可以假设协调，并且可以假设存在一定数量的集中授权。

Monorepo方法的一个不太普遍但也许更合理的担忧是，随着您的组织规模的扩大，每一段代码受到完全相同的法律，合规性，法规，保密性和隐私要求的可能性越来越小。 manyrepo方法的一个固有优势是，单独的存储库显然能够拥有不同组的授权开发人员，可见性，权限等。可以将该功能缝入monorepo，但这意味着在定制和维护方面会产生一些持续的携带成本。

同时，行业似乎一次又一次地发明了轻量级的存储库间链接时代。有时，这是在VCS（Git子模块）或构建系统中。只要存储库集合对
“什么是主干”，“哪些变化首先发生”以及描述依赖关系的机制，我们可以轻松想象将各种不同的物理存储库缝合到一个更大的VMR中。即使Piper为我们做得很好，
投资于高度可扩展的VMR和用于对其进行管理的工具，并依靠现成的自定义来满足每个存储库的策略要求，可能是更好的投资。

一旦有人在OSS社区中构建了足够大的兼容和相互依赖的项目，并发布了这些软件包的VMR视图，我们就怀疑OSS开发人员的做法将开始发生变化。我们看到了这一点
可以合成虚拟monorepo的工具以及大型Linux发行版（例如，发现和发布成千上万个软件包的相互兼容修订版）所做的工作。借助单元测试，CI和针对这些修订版本之一的新提交的自动版本更新功能，包所有者可以（当然，以不间断的方式）更新其包的主干，我们认为该模型将在公开场合流行源世界。毕竟，这仅是效率问题：具有单版本规则的（虚拟）单仓库方法将软件开发的复杂性降低了一个整体（难度）：时间。

我们预计版本控制和依赖性管理将在未来10到20年中朝这个方向发展：VCS将专注于允许具有更好性能扩展的大型存储库，而且还将通过提供以下内容来消除对大型存储库的需求
更好的机制将它们跨项目和组织边界组合在一起。有人，也许是现有的软件包管理小组或Linux发行商，将催化事实上的标准虚拟Monorepo。根据那个仓库中的实用程序，monorepo将提供一个单元轻松访问一组兼容的依赖项。我们会更普遍地认识到版本号是时间戳，允许版本偏斜会增加维数复杂度（时间），而这是很昂贵的，并且我们可以学会避免。从逻辑上像monorepo开始。

### 结论

版本控制系统是技术（尤其是共享计算资源和计算机网络）所提供的协作挑战和机遇的自然延伸。正如我们当时所了解的那样，它们在历史上与软件工程规范同步发展。

早期的系统提供了简单的文件粒度锁定。随着典型的软件工程项目和团队规模的扩大，这种方法的扩展问题变得显而易见，并且我们对版本控制的理解也随之变化以应对这些挑战。然后，随着开发逐渐转向具有分布式贡献者的OSS模型，VCS变得更加分散。我们期望VCS技术发生变化，该技术假定网络具有持续的可用性，将更多的精力放在存储和在云中构建上，从而避免传输不必要的文件和工件。这对于大型，长期存在的软件工程项目而言越来越重要，即使与简单的单开发/单机编程项目相比，这意味着方法上的改变。向云的转移将具体说明DVCS方法已经出现的情况：即使我们允许分布式开发，也必须始终将某些事物集中地视为真相之源。

当前的DVCS分散化是技术对行业（尤其是开源社区）需求的明智反应。但是，必须严格控制DVCS配置，并结合对您的组织有意义的分支机构管理策略。它还经常会带来意想不到的扩展问题：完美的保真度离线操作需要更多的本地数据。无法掌控一切皆有可能的分支的复杂性可能会导致潜在的后果。
开发人员与该代码的部署之间的开销几乎是无限的。但是，不需要以复杂的方式使用复杂的技术：正如我们在基于monorepo和基于主干的开发模型中所看到的那样，保持分支机构策略简单通常可以带来更好的工程结果。

选择导致成本。我们高度认可此处介绍的“单版本规则”：组织内的开发人员不得选择在何处提交或依赖哪个版本的现有组件。我们知道很少有政策会对组织产生如此大的影响：尽管对于单个开发人员来说可能会很烦人，但总的来说，最终结果要好得多。

### TL;DRs

- 将版本控制用于大于“只有一个永远不会更新的开发人员的玩具项目”的任何软件开发项目。
- 在“我应该依赖哪个版本？”中进行选择时，存在一个固有的缩放问题。
- 单版本规则对于提高组织效率非常重要。删除提交位置或依赖内容的选择可能会导致极大的简化。
- 在某些语言中，您可能可以花些功夫通过诸如着色，单独编译，链接器隐藏等技术方法来避免这种情况。使这些方法有效的工作完全是徒劳的-您的软件工程师什么也没做，他们只是在解决技术问题。
- 先前的研究（DORA / DevOps状况/ Accelerate）表明，基于主干的开发是高性能开发组织的预测因素。长期存在的dev分支不是一个好的默认计划。
- 使用对您有意义的任何版本控制系统。如果您的组织希望为单独的项目确定单独的存储库优先级，则最好取消固定存储库间的依赖关系/“从头开始” /“基于中继”。越来越多的VCS和构建系统工具使您既可以使用小型，细粒度的存储库，又可以使用一致的“虚拟”存储库
   整个组织的领导/干系概念。

